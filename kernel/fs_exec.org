* file system(exec.c)

*该功能实现对二进制可执行文件和shell脚本文件的加载与执行*
*do_execve()是它的组要函数,系统调用(int 0x80)功能号__NR_execve()调用的C处理函数,是exec()函数簇的内核实现函数*
*execve()函数主要功能:*
a. 执行对命令行参数和环境参数空间页面的初始化操作
a.0 设置初始空间起始指针,初始化空间页面指针数组为NULL,根据执行文件名取执行对象的i节点,计算参数个数和环境变量个数,检查文件类型,执行权限
b. 根据执行文件开始部分的执行头数据结构,对其中信息进行处理
b.0 根据被执行文件i节点读取文件头部信息,若是shell脚本(#!),则分析shell程序名及参数,并以被执行文件作为参数执行shell程序,执行根据文件的幻数以及段长度等信息判断是否可执行
c. 对当前调用进程进行运行新文件前初始化操作
c.0 指向新执行文件的i节点,复位信号处理句柄,根据头结构信息设置局部描述符基址和段长,设置参数和环境参数页面指针,修改进程各执行字段内容
d. 替换堆栈上原调用execve()程序的返回地址为新执行程序地址,运行新加载的程序
[[./arg_space.png][命令行参数和环境变量字符串空间]]

*copy_string():* 函数用于从用户内存空间拷贝命令行参数和环境字符串到内核空闲页面中
在执行完copy_string()后,再执行linux-0.11(fs/exec.c:333)行语句,p将被调整为从进程逻辑地址空间开始处算起的参数和环境变量起始处指针
*method:* 把一个进程占用的最大逻辑空间长度64M减去参数和环境变量占用的长度(128KB - p)
[[./ptr_head_stack_init.png][p转换成进程初始堆栈指针的方法]]

*create_tables():* 函数用于根据给定的当前堆栈指针p以及参数变量个数argc和环境变量个数envc,在新的程序堆栈中川江环境和参数变量指针表,并返回此时的堆栈指针值,再把该指针值进行页面对其处理,最终得到初始堆栈指针sp
[[./new_process_sp_form.png][创建完毕后新程序堆栈指针表的形式]]

*do_execve():344-345* 会把原调用系统中断程序在堆栈上的代码指针eip替换为指向新执行进程的入口点,并将栈指针替换为新执行文件的栈指针esp
这次系统调用的返回指令最终会弹出这些栈中数据,并使得CPU去执行新执行文件
[[./load_change_esp_eip_in_pkstack.png][加载执行文件过程中栈中esp和eip的变化]]


<内嵌汇编语法>
__asm__(汇编语句模板:输出部分:输入部分:破坏描述部分)

__asm__ __volatile("cli":::"memory")

__volatile__表示编译起不要优化代码

static __inline__ void __set_bit(int nr volatile void *addr)
{
    __asm__(
           "btsl %1, %0"
           :"=m"(addr)
           :"lr"(nr));
}
该功能是将(*addr)的第nr位设为1
等价汇编: btsl nr, addr
“lr" 将nr与立即数或者寄存器相关两

/*
 *功能:从用户空间中addr地址处取出一个字节
 *参数:addr    用户空间中的逻辑地址
 *返回:fs:[addr]处的一个字节内容
 */
extern inline unsigned char get_fs_byte(const char *addr)
{
    unsigned register char _v;
    /*addr是逻辑地址,也就是用户数据段内的偏移*/
    /*而当前数据段为内核数据段,所以要写成fs:[addr],这是虚拟地址*/
    __asm__("movb %%fs:%1, %0“：”=r"(_v):"m"(*addr));
    return _v;
}

/*
 *功能:向用户空间中addr地址处写一个字节的内容
 *参数:val  要写入的数据
 *     addr 用户空间中的逻辑地址
 *返回:(无)
 */
extern inline void put_fs_byte(char val, char *addr)
{
    /*addr是相对于用户数据段的偏移,而当前数据段为内核数据段*/
    /*所以要写成fs:[addr]的形式*/
    __asm__("movb %0, %%fs:%1"::"r"(val),"m"(*addr));
}


*具有输入和输出参数的嵌入式汇编语句基本格式:*
asm("汇编语句":输出寄存器:输入寄存器:会被修改的寄存器);

*一个嵌入式汇编语言函数:*
#define get_seg_byte(seg, addr) ({ \
            register char _res; \             /*定义一个寄存器变量_res*/
            __asm__("push   %%fs; \           /*保存fs寄存器原值*/
                     mov    %%ax, %%fs; \     /*用seg设置fs*/
                     movb   %%fs:%2, %%al; \  /*取seg:addr处1字节内容到al寄存器*/
                     pop    %%fs" \           /*恢复fs起存起原内容*/
                     :"=a"(_res)  \
                     :"0" ((seg)), "m"(*(addr))); \
                     _res; })
    
/*AT&T汇编语句格式,为了让gcc编译产生的汇编语言程序中寄存器名称前有一个百分号"%",在嵌入汇编语句寄存器名称前就必须要写上两个百分号"%%"*/
[[./code_description.png][常用寄存器加载代码说明]]

*C语言关键字volatile*
C语言关键volatile用来修饰变量与__volatile__不同,它表明某个变量的值可能在外部被改变,因此对这些变量的存取不能缓存到寄存器,每次使用时需要重新存取
__asm__ __volatile__("hlt"); "__asm__"表示后面的代码为内嵌汇编,"asm"是"__asm__"的别名,"__volatile__"表示编译器不要优化代码,后面的指令保留原样,"volatile"是它的别名

[[./frame_ibm_pc.png][传统IBM PC及其兼容计算机的组成框图]]


* I/O端口寻址和访问控制方式
** I/O端口和寻址
通常一个I/O控制器包含访问数据的数据端口地址,输出命令的命令端口地址和访问控制器执行状态的状态端口地址
*端口地址的设置方法:* 统一编址和独立编址
*统一编址:* 把I/O控制器中的端口地址归入存储器寻址地址空间范围内,CPU访问一个端口的操作与访问内存的操作一样,使用访问内存的指令
*独立编址:* 把I/O控制器和控制卡的寻址空间单独作为一个独立的地址空间对待,成为I/O地址空间,每个端口有一个I/O地址与之对应,并且使用专门的I/O指令来访问端口
使用ISA总线结构的传统PC机其I/O地址空间范围是0x000 ~ 0x3FF 有1024个I/O端口地址可供使用

CGA显卡上显示内存采用了统一编址方式,内存地址直接占用了存储器地址空间0xB800 ~ 0xBC00范围,若想在屏幕上显示一个字符,可直接使用内存操作指令往该内存区域执行写操作

[[./port_address.png][各个控制器和控制卡所默认分配使用的端口地址范围]]
** 接口访问控制
1.程序轮询方式
2.中断处理方式
3. DMA传输方式 (用于I/O设备于系统内存之间进行批量数据传送)
* 主存储器 BIOS和CMOS存储器
** 主存储器
当计算机商店初始化时,物理内存被设置成从地址0开始的连续区域,除了地址从0xA0000到0xFFFFF(640k到1M共384k)
和0xFFFE0000到0xFFFFFFFF(4G处的组后64k)范围之外的所有内存都可用作系统内存,这两个范围被用于I/O设备和BIOS程序
*Example:*
假设计算机中有16MB的物理内存,在linux0.1x系统中,0 ~ 640k被用作存放内核代码和数据,Linux内核不实用BIOS功能,
也不实用BIOS设置的中断向量表,640k ~ 1M之间的384k仍然保留用作图中指明的用途,其中地址0xA0000开始的128k用作显示
缓冲区,随后部分用于其他控制卡的ROM BIOS或其映射区域,而0xF0000到1M范围用于高端系统ROM BIOS的映射区,1M ~ 16M被
内核用于作为可分配的主内存区,另外告诉缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域,该区域通常
会跨越640k ~ 1M的区域
[[./pc_at_mem_use.png][PC/AT机内存使用区域图]]
** 基本输入/输出程序BIOS
[[./flash_rom_bios.png][Flash ROM BIOS位置和复制映射区域]]
** CMOS存储器
CMOS内存的地址空间在基本内存地址空间之外,需要使用I/O指令来访问,容量一般为64或128字节,存放实时时钟信息和系统硬件配置信息
* 控制器和控制卡
** 中断控制器
[[./8259a_double.png][PC/AT微机级联式8259控制系统]]
[[./rom_bios_args.png][开机时ROM BIOS设置的硬件请求处理中断号]]
Linux操作系统并不直接使用这些PC机默认设置好的中断向量号,当Linux系统执行初始化操作时,它重新设置中断请求号与中断向量
号的对应关系
** DMA控制器
Intel8237芯片或其兼容芯片实现
三个端口的设置:页面寄存器端口,(偏移)地址寄存器端口,数据计数寄存器端口
** 定时/计数器
Intel8253／8254
** 键盘控制器
Intel8042
[[./keypad_decoding.png][键盘控制器对扫描码集的转换]]
** 串行控制卡
[[./frame_struct.png][通信幀的一般结构]]
16650A芯片
** 显示控制
** 软盘和硬盘控制器
* 目标文件格式
** a.out目标文件格式
1. 文件头
2. 代码区(正文段)
3. 已初始化数据区(数据段)
4. 重定位信息区
5. 符号表
6. 符号名字字符串
[[./a.out_form.png][a.out格式的目标文件]]

*各个区的基本定义和用途:*
a. 执行头部分
该部分中含有一些参数(exec结构),时有关目标文件的整体结构信息,例如:
代码和数据区的长度,未初始化数据区的长度,对应源程序文件名以及目标文件创建时间等,
内核使用这些参数把文件加载到内存中并执行,而链接程序(ld)使用这些参数将一些模块文件
组合成一个可执行文件
b. 代码区
由编译器或汇编器生成的二进制命令代码和数据信息,含有程序执行时被加载到内存中的指令代码和相关数据
c. 数据区
由编译器或汇编器生成的二进制指令代码和数据信息,该部分含有已经初始化过的数据,总被加载到刻度可写的内存中
d. 代码重定位部分
该部分含有供链接程序使用的记录数据,在组合目标模块文件时用于定位代码段中的指针或地址,当链接程序需要改变
目标代码的地址时就需要修正和维护这些地方
e. 数据重定位部分
类似于代码重定位部分的作用,但是用于数据段中指针的重定位
f. 符号表部分
该部分同样含有供链接程序使用的记录数据,这些记录保存着模块文件中定义的全局符号以及需要从其他莫跨哦文件中输入
的符号,或者是由连接器定义的符号,用于在模块文件之间对命名的变量和函数(符号)进行交叉引用
g. 字符串表部分
该部分含有与符号名相对应的字符串,用于调试程序调试目标代码,与链接程序无关,这些信息可包含源程序代码和行号,局部
符号以及数据结构描述信息等
** 执行头文件
目标文件的文件头中含有一个长度32字节的exec数据结构,通常称为文件头结构或执行头结构,其定义如下:
struct exec {
       unsigned long a_magic;             //执行文件魔数,使用N_MAGIC等宏访问
       unsigned a_text;                   //代码长度,字节数
       unsigned a_data;                   //数据长度,字节数
       unsigned a_bss;                    //文件中的未初始化数据区长度,字节数
       unsigned a_syms;                   //文件中的符号表长度,字节数
       unsigned a_entry;                  //执行开始地址
       unsigned a_trsize;                 //代码重定位信息长度,字节数
       unsigned a_drsize;                 //数据重定位信息长度,字节数
}

根据文件中头结构魔数字段的值,可以把a.out格式的文件分成几种类型
OMAGIC类型的a.out格式  魔数0x107
ZMAGIC类型的a.out格式  魔数0x10b

虽然该结构的总长度只有32字节,但对于一个ZMAGIC类型的执行文件来说,其文件开始部分却需要专门留出1024字节的
空间给头结构使用,除被头结构占用的32个字节以外,其余部分均为0,从1024字节之后才开始放置程序的正文段和数据段
等信息;而对于一个OMAGIC类型的.o模块文件来说,文件开始部分的32字节头结构后就紧接着就是代码区和数据区
** 重定位信息部分
Linux0.11系统的模块文件和执行文件都是a.out格式的目标文件,但是只有编译器生成的模块文件中包含用于链接程序的
重定位信息,代码段和数据段的重定位信息均有重定位记录项构成,每个记录的长度为8字节,结构如下:
struct relocation_info {
       int r_address;                 //段内需要重定位的地址
       unsigned int r_symbolnum:24    //含义与r_extern有关,指定符号表中一个符号或者一个段
       unsigned int r_pcrel:1;        //1比特,PC相关标识
       unsigned int r_length:2;       //2比特,指定要被重定位字段长度(2的次方)
       unsigned int r_extern:1;       //外部标志位,1-以符号的值重定位 0-以段的地址重定位
       unsigned int r_pad:4;          //没有使用的4比特,但最好将他们复位掉
};
** 符号表和字符串部分
*符号表记录项结构:*
struct nlist {
       union {
             char *n_name;          //字符串指针
             struct nlist *n_next;  //指向另一个符号项结构的指针
             long  n_strx;          //符号名称在字符串表中的字节偏移量
       } n_un;

       unsigned char n_type;        //该字节分成3个字段
       char          n_other;       //通常不用
       short         n_desc;
       unsigned long n_value;       //符号的值
};
** Linux0.11中的目标文件格式
使用objdump命令来查看模块文件或执行文件中文件头结构的具体值

$hexdump -x hello.o

$objdump -h hello.o

我们可以使用命令strip命令上除执行文件中的符号表信息
$strip hello

[[./a.out_map_2_logical_address.png][a.out执行文件映射到进程逻辑地址空间]]
** 链接程序输出
[[./link_target.png][目标文件的链接操作]]
工具程序build主要功能就是分别去掉bootsect, setup, system文件中的执行头结构,然后把他们顺序结合在一起产生一个名
为Image的内核映像文件
现在Linux系统中程序代码从其逻辑地址0x08048000处开始存放
