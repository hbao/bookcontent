* file system(exec.c)

*该功能实现对二进制可执行文件和shell脚本文件的加载与执行*
*do_execve()是它的组要函数,系统调用(int 0x80)功能号__NR_execve()调用的C处理函数,是exec()函数簇的内核实现函数*
*execve()函数主要功能:*
a. 执行对命令行参数和环境参数空间页面的初始化操作
a.0 设置初始空间起始指针,初始化空间页面指针数组为NULL,根据执行文件名取执行对象的i节点,计算参数个数和环境变量个数,检查文件类型,执行权限
b. 根据执行文件开始部分的执行头数据结构,对其中信息进行处理
b.0 根据被执行文件i节点读取文件头部信息,若是shell脚本(#!),则分析shell程序名及参数,并以被执行文件作为参数执行shell程序,执行根据文件的幻数以及段长度等信息判断是否可执行
c. 对当前调用进程进行运行新文件前初始化操作
c.0 指向新执行文件的i节点,复位信号处理句柄,根据头结构信息设置局部描述符基址和段长,设置参数和环境参数页面指针,修改进程各执行字段内容
d. 替换堆栈上原调用execve()程序的返回地址为新执行程序地址,运行新加载的程序
[[./arg_space.png][命令行参数和环境变量字符串空间]]

*copy_string():* 函数用于从用户内存空间拷贝命令行参数和环境字符串到内核空闲页面中
在执行完copy_string()后,再执行linux-0.11(fs/exec.c:333)行语句,p将被调整为从进程逻辑地址空间开始处算起的参数和环境变量起始处指针
*method:* 把一个进程占用的最大逻辑空间长度64M减去参数和环境变量占用的长度(128KB - p)
[[./ptr_head_stack_init.png][p转换成进程初始堆栈指针的方法]]

*create_tables():* 函数用于根据给定的当前堆栈指针p以及参数变量个数argc和环境变量个数envc,在新的程序堆栈中川江环境和参数变量指针表,并返回此时的堆栈指针值,再把该指针值进行页面对其处理,最终得到初始堆栈指针sp
[[./new_process_sp_form.png][创建完毕后新程序堆栈指针表的形式]]

*do_execve():344-345* 会把原调用系统中断程序在堆栈上的代码指针eip替换为指向新执行进程的入口点,并将栈指针替换为新执行文件的栈指针esp
这次系统调用的返回指令最终会弹出这些栈中数据,并使得CPU去执行新执行文件
[[./load_change_esp_eip_in_pkstack.png][加载执行文件过程中栈中esp和eip的变化]]


<内嵌汇编语法>
__asm__(汇编语句模板:输出部分:输入部分:破坏描述部分)

__asm__ __volatile("cli":::"memory")

__volatile__表示编译起不要优化代码

static __inline__ void __set_bit(int nr volatile void *addr)
{
    __asm__(
           "btsl %1, %0"
           :"=m"(addr)
           :"lr"(nr));
}
该功能是将(*addr)的第nr位设为1
等价汇编: btsl nr, addr
“lr" 将nr与立即数或者寄存器相关两

/*
 *功能:从用户空间中addr地址处取出一个字节
 *参数:addr    用户空间中的逻辑地址
 *返回:fs:[addr]处的一个字节内容
 */
extern inline unsigned char get_fs_byte(const char *addr)
{
    unsigned register char _v;
    /*addr是逻辑地址,也就是用户数据段内的偏移*/
    /*而当前数据段为内核数据段,所以要写成fs:[addr],这是虚拟地址*/
    __asm__("movb %%fs:%1, %0“：”=r"(_v):"m"(*addr));
    return _v;
}

/*
 *功能:向用户空间中addr地址处写一个字节的内容
 *参数:val  要写入的数据
 *     addr 用户空间中的逻辑地址
 *返回:(无)
 */
extern inline void put_fs_byte(char val, char *addr)
{
    /*addr是相对于用户数据段的偏移,而当前数据段为内核数据段*/
    /*所以要写成fs:[addr]的形式*/
    __asm__("movb %0, %%fs:%1"::"r"(val),"m"(*addr));
}


*具有输入和输出参数的嵌入式汇编语句基本格式:*
asm("汇编语句":输出寄存器:输入寄存器:会被修改的寄存器);

*一个嵌入式汇编语言函数:*
#define get_seg_byte(seg, addr) ({ \
            register char _res; \             /*定义一个寄存器变量_res*/
            __asm__("push   %%fs; \           /*保存fs寄存器原值*/
                     mov    %%ax, %%fs; \     /*用seg设置fs*/
                     movb   %%fs:%2, %%al; \  /*取seg:addr处1字节内容到al寄存器*/
                     pop    %%fs" \           /*恢复fs起存起原内容*/
                     :"=a"(_res)  \
                     :"0" ((seg)), "m"(*(addr))); \
                     _res; })
    
/*AT&T汇编语句格式,为了让gcc编译产生的汇编语言程序中寄存器名称前有一个百分号"%",在嵌入汇编语句寄存器名称前就必须要写上两个百分号"%%"*/
[[./code_description.png][常用寄存器加载代码说明]]

*C语言关键字volatile*
C语言关键volatile用来修饰变量与__volatile__不同,它表明某个变量的值可能在外部被改变,因此对这些变量的存取不能缓存到寄存器,每次使用时需要重新存取
__asm__ __volatile__("hlt"); "__asm__"表示后面的代码为内嵌汇编,"asm"是"__asm__"的别名,"__volatile__"表示编译器不要优化代码,后面的指令保留原样,"volatile"是它的别名

[[./frame_ibm_pc.png][传统IBM PC及其兼容计算机的组成框图]]


* I/O端口寻址和访问控制方式
** I/O端口和寻址
通常一个I/O控制器包含访问数据的数据端口地址,输出命令的命令端口地址和访问控制器执行状态的状态端口地址
*端口地址的设置方法:* 统一编址和独立编址
*统一编址:* 把I/O控制器中的端口地址归入存储器寻址地址空间范围内,CPU访问一个端口的操作与访问内存的操作一样,使用访问内存的指令
*独立编址:* 把I/O控制器和控制卡的寻址空间单独作为一个独立的地址空间对待,成为I/O地址空间,每个端口有一个I/O地址与之对应,并且使用专门的I/O指令来访问端口
使用ISA总线结构的传统PC机其I/O地址空间范围是0x000 ~ 0x3FF 有1024个I/O端口地址可供使用

CGA显卡上显示内存采用了统一编址方式,内存地址直接占用了存储器地址空间0xB800 ~ 0xBC00范围,若想在屏幕上显示一个字符,可直接使用内存操作指令往该内存区域执行写操作

[[./port_address.png][各个控制器和控制卡所默认分配使用的端口地址范围]]
** 接口访问控制
1.程序轮询方式
2.中断处理方式
3. DMA传输方式 (用于I/O设备于系统内存之间进行批量数据传送)
* 主存储器 BIOS和CMOS存储器
** 主存储器
当计算机商店初始化时,物理内存被设置成从地址0开始的连续区域,除了地址从0xA0000到0xFFFFF(640k到1M共384k)
和0xFFFE0000到0xFFFFFFFF(4G处的组后64k)范围之外的所有内存都可用作系统内存,这两个范围被用于I/O设备和BIOS程序
*Example:*
假设计算机中有16MB的物理内存,在linux0.1x系统中,0 ~ 640k被用作存放内核代码和数据,Linux内核不实用BIOS功能,
也不实用BIOS设置的中断向量表,640k ~ 1M之间的384k仍然保留用作图中指明的用途,其中地址0xA0000开始的128k用作显示
缓冲区,随后部分用于其他控制卡的ROM BIOS或其映射区域,而0xF0000到1M范围用于高端系统ROM BIOS的映射区,1M ~ 16M被
内核用于作为可分配的主内存区,另外告诉缓冲区和内存虚拟盘也会占用内核代码和数据后面的一部分内存区域,该区域通常
会跨越640k ~ 1M的区域
[[./pc_at_mem_use.png][PC/AT机内存使用区域图]]
** 基本输入/输出程序BIOS
[[./flash_rom_bios.png][Flash ROM BIOS位置和复制映射区域]]
** CMOS存储器
CMOS内存的地址空间在基本内存地址空间之外,需要使用I/O指令来访问,容量一般为64或128字节,存放实时时钟信息和系统硬件配置信息
* 控制器和控制卡
** 中断控制器
[[./8259a_double.png][PC/AT微机级联式8259控制系统]]
[[./rom_bios_args.png][开机时ROM BIOS设置的硬件请求处理中断号]]
Linux操作系统并不直接使用这些PC机默认设置好的中断向量号,当Linux系统执行初始化操作时,它重新设置中断请求号与中断向量
号的对应关系
** DMA控制器
Intel8237芯片或其兼容芯片实现
三个端口的设置:页面寄存器端口,(偏移)地址寄存器端口,数据计数寄存器端口
** 定时/计数器
Intel8253／8254
** 键盘控制器
Intel8042
[[./keypad_decoding.png][键盘控制器对扫描码集的转换]]
** 串行控制卡
[[./frame_struct.png][通信幀的一般结构]]
16650A芯片
** 显示控制
** 软盘和硬盘控制器
