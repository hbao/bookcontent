* Unix下可用的5中I/O模型的基本区别
*输入操作包含的两个不同阶段:*
1. 等待数据准备好
2. 从内核到进程拷贝数据

*对于一个套接字上的输入操作:*
1. 涉及等待数据从网络中到达,当所等待分组到达时,它被拷贝到内核中的某个缓冲区
2. 把数据从内核缓冲区拷贝到应用进程缓冲区

** 阻塞I/O
*blocking I/O Module:*
缺省情况下所有套接字都是阻塞的(以数据报套接字为例)
                  应用进程                                  内核
                                    系统调用
              ｜  recvfrom     ------------------->    无数据报准备好   ｜
              ｜                                             |          ｜
              ｜                                             |          ｜等待数据
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
  进程阻塞于  ｜                                        数据报准备好
recvfrom的调用｜                                          拷贝数据报
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜将数据从内核
              ｜                                             |          ｜拷贝到用户空间
              ｜                                             |          ｜
              ｜                     返回成功指示            |          ｜
              ｜  处理数据报    <-------------------       拷贝完成     ｜
UDP对数据准备好读取的概念比较简单,妖媚整个数据报已经收到,要么没有;而对于TCP来说概念相对比较复杂
** 非阻塞I/O
*nonblocking I/O Module:*
进程把一个套接字设置成非阻塞是在通知内核:当所请求的I/O操作非得把本进程投入睡眠才能完成时,不要把该进程投入睡眠,而是返回一个错误
                  应用进程                                  内核
                                    系统调用
              ｜  recvfrom     ------------------->    无数据报准备好   ｜
              ｜                    EWOULDBLOCK              |          ｜
              ｜               <-------------------          |          ｜
              ｜                    系统调用                 |          ｜ 
              ｜  recvfrom     ------------------->    无数据报准备好   ｜等待数据
              ｜                    EWOULDBLOCK              |          ｜
              ｜               <-------------------          |          ｜
                                    系统调用                 |          ｜
              ｜  recvfrom     ------------------->    无数据报准备好   ｜
              ｜                    EWOULDBLOCK              |          ｜
              ｜               <-------------------          |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                    系统调用                 |          ｜
进程反复调用  ｜  recvfrom     ------------------->      数据报准备好
recvfrom等待返｜                                          拷贝数据报
  回成功指示  ｜                                             |          ｜
    (轮询)    ｜                                             |          ｜
              ｜                                             |          ｜将数据从内核
              ｜                                             |          ｜拷贝到用户空间
              ｜                                             |          ｜
              ｜                     返回成功指示            |          ｜
              ｜  处理数据报    <-------------------       拷贝完成     ｜

前三次调用recvfrom时没有数据可返回,因此内核立即返回一个EWOULDBLOCK错误,第四次调用recvfrom时已有一个数据报准备好了,它被拷贝到应用进程缓冲区,recvfrom返回成功,然后处理数据
当一个应用进程像这样对一个非阻塞描数字循环调用recvfrom时,我们称之为轮询polling,应用进程持续轮询内核,以查看某个操作是否就绪,该做法往往耗费大量CPU时间,因此通常在只专门提供某种功能的系统中才有
** I/O复用(select和poll)
I/O复用使我们可以调用select或poll,阻塞在这两个系统调用中的某一个之上,而不是阻塞在真正的I/O系统调用上
                  应用进程                                  内核
                                    系统调用
              ｜  select       ------------------->    无数据报准备好   ｜
进程受阻于    ｜                                             |          ｜
select调用    ｜                                             |          ｜
等待可能多    ｜                                             |          ｜等待数据
个套接字中    ｜                                             |          ｜
的任一一个    ｜                                             |          ｜
变为可读      ｜                    返回可读条件             |          ｜
                               <-------------------    数据报准备好     
                  recvfrom     ------------------->     拷贝数据报     
              ｜                    系统调用                 |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
  数据拷贝到  ｜                                             |          ｜
应用缓冲区期间｜                                             |          ｜
  进程阻塞    ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜将数据从内核
              ｜                                             |          ｜拷贝到用户空间
              ｜                                             |          ｜
              ｜                     返回成功指示            |          ｜
              ｜  处理数据报    <-------------------       拷贝完成     ｜
阻塞于select调用,等待数据报套接字变为可读,当select返回套接字可读时,调用recvfrom把所有数据报拷贝到应用进程缓冲区
使用select的优势在于我们可以等待多个描数字就绪
与I/O复用密切相关的另一种I/O模型是在多线程中使用阻塞I/O,这种模型与上述模型极为相似,代替使用select阻塞在多个文件描述字上的是,使用多个线程(每个文件描数字一个线程),这样每个县城就都可以自由地调用诸如recvfrom之类的阻塞式I/O系统调用
** 信号驱动I/O(SIGIO)
可以使用信号机制,让内核在描数字就绪时发送SIGIO信号通知我们(signal-driven I/O)信号驱动I/
                  应用进程                                  内核
                                系统调用sigaction
              ｜  建立SIGIO    ------------------->                     ｜
程序继续执行  ｜  信号处理程序 <-------------------                     ｜
              ｜                     返回                               ｜
              ｜                                                        ｜等待数据
              ｜                                                        ｜
              ｜                                                        ｜
              ｜                    返回可读条件                        ｜
                  信号处理程序 <-------------------    数据报准备好     
                  recvfrom     ------------------->     拷贝数据报     
              ｜                    系统调用                 |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜
  数据拷贝到  ｜                                             |          ｜
应用缓冲区期间｜                                             |          ｜
  进程阻塞    ｜                                             |          ｜
              ｜                                             |          ｜
              ｜                                             |          ｜将数据从内核
              ｜                                             |          ｜拷贝到用户空间
              ｜                                             |          ｜
              ｜                     返回成功指示            |          ｜
              ｜  处理数据报    <-------------------       拷贝完成     ｜
首先开启套接字的信号驱动I/O功能,并通过sigaction系统调用安装一个信号处理函数,该系统调用将立即返回,进程继续工作(未阻塞),当数据报准备好读取时,内核就为该进程产生一个SIGIO信号,随后即可在信号处理函数中调用recvfrom读取数据,并通知主循环数据已准备好待处理
该模型的优势在于等待数据报到达期间,进程不被阻塞,主循环可以继续执行,只要不时等待来自信号处理函数的通知(可以是数据已准备好被处理,或者数据报已准备好被读取)
** 异步I/O(POSIX的aio_系列函数)
asynchronous I/O  POSIX规范定义
函数工作机制:告知内核启动某种操作,并让内核在整个操作(包括将数据从内核拷贝到我们自己的缓冲区)完成后通知我们

信号驱动I/O是由内核通知我们何时可以启动一个I/O操作
异步I/O模型是由内核通知我们I/O操作何时完成
                  应用进程                                  内核
                                    系统调用
              ｜  aio_read      ------------------->    无数据报准备好   ｜
              ｜                <-------------------          ｜         ｜
              ｜                    返回                      ｜    　　 ｜
进程继续执行　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜等待数据
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　 数据报准备好
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　拷贝数据报　　　
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜
　　　　　　　｜　　　　　　　　　　　　　　　　　　　　　　　｜　　　　 ｜将数据从内核
　　　　　　　｜　信号处理　　　　　　递交在aio_read中　　　　｜　　　　 ｜ 拷贝到用户空间
　　　　　　　｜　程序处理　　　<---------------------    拷贝完成　　　 ｜
　　　　　　　　　　数据报

POSIX异步以aio_或lio_开头,调用aio_read函数给内核传递描数字,缓冲区指针,缓冲区大小,文件偏移量,并告诉内核当整个操作完成时如何通知我们
该系统调用立即返回,在等待I/O完成期间,我们的进程不被阻塞  并不多见

同步I/O(synchronous I/O)导致请求进程阻塞,直到I/O操作完成
异步I/O(asynchronous I/O)不导致请求进程阻塞
